# 사용자 수에 따른 규모 확장성

### 단일 서버
![ch1_basic](https://github.com/wonjunYou/techinical-book/assets/59856002/4de3729f-5f91-4eac-b116-6b3987da24e5)

1. 사용자는 도메인 이름을 이용하여 웹사이트에 접속한다. 
* 해당 접속을 위해서는 도메인 이름을 도메인 이름 서비스(DNS)에 질의하여 IP 주소로 변환하는 과정이 필요하다.
* DNS는 보통 third-party가 제공하는 유료 서비스를 이용한다.
2. DNS 조회 결과로 IP 주소가 반환된다.
3. 해당 IP 주소로 HTTP 요청 전달
4. 요청을 받은 웹 서버는 HTML 페이지나 JSON 형태의 응답을 반환한다.

<br>

### 어떤 DB를 사용할 것인가? - NoSQL
* 비 관계형 데이터베이스이며, 대표적으로 CouchDB, Neo4j, Cassandra, Redis, MongoDB등이 있다.
* 비 관계형 데이터베이스가 적합한 경우?
  * 아주 낮은 응답 지연시간(latency) 가 필요한 경우
  * 다루는 데이터가 비정형이라 관계형 데이터가 아님
  * 데이터(json, yaml)등을 직렬화, 역직렬화가 가능한 경우
  * 아주 많은 양의 데이터를 저장해야 할 때

<br>

### Scale-up vs Scale-out
* Scale-up이란, 서버에 고사양 자원(더 좋은 CPU, 더 많은 RAM)을 추가하는 행위를 말한다.
  * 서버로 유입되는 트래픽의 양이 적을 때는 수직적 확장이 좋다.
  * 장점 : 단순함
  * 단점 1 : 무한정 cpu나 메모리를 증설할 수는 없다.
  * 단점 2 : failover(자동 복구) 방안이나 다중화(redundancy) 방안이 없다.
  * 따라서 대규모 애플리케이션의 경우 scale-out이 적절하다.
* Scale-out이란, 더 많은 서버를 추가하여 성능을 개선하는 행위를 말한다.

<br>

### 로드밸런서
> 로드밸런서란, 부하 분산 집합(load balancing set)에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할을 한다.

![ch1_loadBalancer](https://github.com/wonjunYou/techinical-book/assets/59856002/d59d4375-b020-4642-9170-a280018bc538)

* 위 그림과 같이, 사용자는 로드밸런서의 공개 IP 주소로 접속한다. 따라서 웹 서버가 클라이언트의 접속을 직접 처리하지는 않는다.
* 서버간 통신에는 보안을 위해 사설 IP 주소(private IP address)가 이용된다.
  * 같은 IP 네트워크에 속한 서버 사이 통신에만 사용 가능, 인터넷을 통해 접속은 불가능.
* load balancing set에 다른 웹 서버 하나를 추가하면 failover가 가능해지고, 결과적으로 가용성(availability)가 향상된다.

<br>

### DB 다중화
DB 다중화란 일반적으로 DB 복제(DB replication)을 통해 이루어지며 서버 사이에 master-slave 관계를 설정하고 원본은 master, 사본은 slave에 저장하는 방식이다.
* 쓰기 연산은 master에서만 지원한다.
* slave는 읽기(read)만 가능하다.
* 대부분 db에서는 읽기 작업의 비율이 훨씬 높으므로, slave db가 훨씬 많다.

![ch1_db_replication](https://github.com/wonjunYou/techinical-book/assets/59856002/5be7a0be-7403-4d1b-86dc-a947ab3346a9)

DB 다중화를 통해 얻을 수 있는 장점은 다음과 같다.
* 성능 개선 - 읽기와 쓰기 쿼리를 나누어 병렬로 처리하므로, 성능이 개선된다.
* 안정성 - DB 서버 중 일부가 파괴되어도 데이터가 보존될 것.
* 가용성 - 장애 발생 시 다른 서버의 데이터를 활용하므로 계속 서비스가 가능하다.

만약 master server가 다운된다면?
* slave 서버 중 하나가 새로운 master가 된다. 
  * 하지만, 해당 서버의 데이터가 최신 상태가 아닐 수 있다는 문제가 있다.
  * 이는 recovery script(복구 스크립트)를 돌려 수동으로 추가한다.
    * multi-masters(다중 master), 원형 다중화(circular replication) 방식을 도입하면 대처 가능.

![ch1_total_architecture](https://github.com/wonjunYou/techinical-book/assets/59856002/15e6c909-72f8-4fca-bc10-d53ec4c618a9)
최종적인 아키텍처는 다음과 같고, 동작 과정은 아래와 같다.
* 사용자는 DNS로부터 로드밸런서의 공개 IP주소를 받는다.
* 해당 IP 주소를 사용해 로드밸런서에 접속한다.
* HTTP 요청은 서버 1 or 2로 전달된다.
* 웹 서버는 사용자의 데이터를 부 데이터베이스 서버에서 읽는다.
* 웹 서버는 데이터 변경 연산은 주 데이터베이스로 전달한다.
* 데이터 추가, 삭제, 갱신 연산 등이 이에 해당한다.

### 응답시간 개선 - Cache
캐시란, 값비싼 연산 결과 혹은 자주 참조되는 데이터를 메모리 안에 두고 같은 요청이 빨리 처리될 수 있도록 하는 저장소다.

* 애플리케이션 성능은 DB I/O를 적게 발생시켜야 하므로, 캐시를 통해 이를 달성할 수 있다.

동작 과정은 다음과 같다.
1. 요청을 받는 웹 서버가 캐시에 해당 응답이 저장되어 있는지 체크
2. 만약 저장되어 있다면 반환한다.
3. 하지만 저장되어 있지 않다면, DB에 쿼리를 통해 캐시에 저장한 뒤 클라이언트로 반환한다.

### 캐시 사용 시 유의할 점
* 캐시는 데이터 갱신(insert, update, delete)가 적고 조회가 잦다면 고려할 수 있다.
* 어떤 데이터를 캐시에 둘 것인가?
  * 영구 저장해야 하는 데이터를 캐시에 두면 안된다. 캐시는 휘발성이 있다.
* 캐시 만료 정책을 어떻게 설정할까?
  * 만료 기한을 설정할 수 있고, 너무 짧으면 캐시의 효과가 떨어지고 너무 길면 원본과 차이가 날 수 있다.
* 캐시와 db의 일관성을 어떻게 유지하는가?
  * 위 캐시의 동작 과정이 단일 트랜잭션으로 처리되지 않으면 일관성 유지가 어렵다.
* 캐시 서버에 장애가 나면 어떻게 할 것인가?
  * 만약 캐시 서버가 하나라면, 단일 장애 지점(SPOF, Single Point of Failure)가 될 가능성이 있다.
* 캐시 메모리 사이즈 문제
* 데이터 방출 정책
  * 캐시가 꽉 차면 어떤 기준으로 데이터를 방출할 것인가?
  * LRU(Least Recently Used)
  * LFU(Lesat Frequently Used)
  * FIFO 등

### 콘텐츠 전송 네트워크(CDN)
정적 콘텐츠를 전송하는 데 쓰이는 지리적으로 분산된 서버의 네트워크이다.
이미지, 비디오, CSS, JS파일 등을 캐시할 수 있다.

어떤 사용자가 웹사이트를 방문하면, 사용자에게 가장 가까운 CDN 서버가 정적 콘텐츠를 전달한다.
지리적으로 사용자가 CDN 서버로부터 멀면 멀수록 웹사이트는 천천히 로드될 것이다.

전 세계에 여러 개의 CDN 서버를 둠으로서, 모든 사용자가 빠르게 웹 사이트를 응답할 수 있도록 지원한다.

### 무상태(stateless) 웹 계층
Scale-out을 달성하기 위해서는 상태 정보(사용자 세션 데이터와 같은)를 웹 계층에서 제거하여야 한다.
* 상태 정보를 관계형 DB나 NoSQL같은 지속성 저장소에 보관하고 필요할 때 가져오도록 하는 것.

로그인을 예로 들면, 만약 여러 개의 서버가 세션 정보를 다르게 갖고 있다면 특정 사용자의 경우
해당 세션 정보를 가진 서버에서 처리해야 하는 제약이 발생한다.

-> 이를 해결하기 위해 로드밸런서에서 고정 세션(sticky session)이라는 기능을 제공하나 로드밸런서에 부담을 준다.

### 메세지 큐(Message queue)
메세지 큐란, 메세지의 무손실(durability)과 비동기통신을 지원하는 컴포넌트다.
* 무손실이란, 메세지 큐에 일단 보관된 메세지는 소비자가 꺼낼 때까지 안정적으로 보관된다는 특성이다.
* producer가 메세지 큐에 메세지를 반들어 발행(publish)한다.
* 해당 큐에는 consumer(소비자, 구독자)가 연결되어 있으며 메세지를 받아 그에 맞는 동작을 수행한다.

메세지 큐를 이용하면 서비스-서비스, 서버-서버 간 결합이 느슨해지므로 scale-out에 용이하다.
* 생산자와 소비자 중 한 쪽이 다운되어도 자신의 역할 수행에 문제가 없다.
* 사용 예) 시간이 오래 걸리는 사진 보정 어플리케이션을 제작하는 경우
  * 사진 보정 작업을 메세지 큐에 넣는다.
  * worker(consumer) process는 해당 작업들을 메세지 큐에서 꺼내어 비동기적으로 완료한다.

+ 로그, 매트릭, 모니터링, 자동화(CI)도 중요하다.

### DB의 규모 확장
DB 역시 Scale-up, Scale-out을 고려할 수 있다.

**Scale up**
* 스택오버플로는 한 해 동안 방문한 1천만명의 유저를 한 대의 master DB로 처리하였다.
* 역시 웹 서버와 마찬가지로 SPOF, 비용, 확장의 한계가 있다.

**Scale-out**
샤딩(sharding)이라고도 불리며 대규모 db를 샤드(shard)라고 부르는 작은 단위로 분할한다.
같은 스키마를 사용하나 샤드에 보관되는 데이터 사이에는 중복이 없다.

이때 고민해야 할 점은, 샤딩 키(sharding key) 즉 데이터가 어떻게 분산될지 정하는 컬럼과 기준을 잘 설정해야 한다.
* 특정 샤드에 query가 집중되는 경우(hotspot key)
* 조인과 비정규화
  * 샤딩을 하면 당연하게도 어렵다. 이를 해결하려면 다시 비정규화하여 합쳐야 한다.
  
### Outro.
* 웹 계층은 무상태 계층으로.
* 모든 계층에 다중화 도입
* 가능한 많은 데이터를 캐싱
* 여러 데이터 센터를 지원
* 정적 콘텐츠는 웹서버 대신 CDN을 통해 서비스할 것.
* 데이터 계층은 샤딩을 통해 규모를 확장할 것.
* 각 계층은 독립적 서비스로 분할할 것.
* 시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것.