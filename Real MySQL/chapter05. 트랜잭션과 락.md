# 트랜잭션과 잠금

## MySQL에서의 트랜잭션
* 트랜잭션은 꼭 여러 개의 변경 작업을 수행하는 쿼리가 조합됐을 때만 의미 있는 개념은 아니다.
* 하나의 논리적인 작업 셋에 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 무관하다.
  * 단지 ALL Commit or All Rollback을 해야 한다.
* MySQL에서도 메모리 기반 스토리지 엔진인 MyISAM, InnoDB 스토리지 기반 엔진이 있다.
  * MyISAM, MEMORY는 트랜잭션을 지원하지 않는다.

ALL COMMIT, OR ALL ROLLBACK이라는 Transaction의 원자성을 보장하지 않으므로
MyISAM 테이블에서는 부분 업데이트 문제가 발생한다.(정합성의 보장이 어려워진다.)

* 트랜잭션의 범위를 최소화하라.
* DB 커넥션의 개수가 한정적.
  * 메일 전송이나 FTP 파일 전송 작업 등 네트워크를 통해 원격 서버와 통신하는 작업은 어떻게 해서든 DBMS의 트랜잭션 내에서 제거하는 것이 좋다.
* 비슷한 작업은 한 트랜잭션 내에서 처리하도록 하고, 성격이 다른 작업들은 별도의 트랜잭션으로 분리하라.

## MySQL 엔진의 레벨의 Lock

### Lock의 레벨(스토리지 엔진 레벨, MySQL 엔진 레벨)
크게 **스토리지 엔진 레벨과 MySQL 엔진 레벨로 나눌 수 있다.** 
MySQL 엔진이란 MySQL 서버에서 스토리지 엔진을 제외한 나머지 부분으로 이해하면 된다.

* MySQL 엔진 레벨 -> 모든 스토리지 엔진에 영향을 미침.
  * 테이블 데이터 동기화를 위한 테이블 락, 테이블의 구조를 잠그는 메타데이터 락, 사용자의 필요에 맞게 사용 가능한 네임드 락
* 스토리지 엔진 레벨 -> 스토리지 엔진 간에 상호 영향은 없음.'

### 글로벌 락(GLOBAL LOCK)
> 💡FLUSH TABLES WITH READ LOCK

MySQL에서 제공하는 락 가운데 가장 범위가 크다.(대상 : MySQL 서버 전체)
-> 작업 대상 테이블이나 DB가 다르더라도 동일하게 영향을 미친다.

한 세션에서 글로벌 락을 획득시, 다른 세션에서 쓰기 작업을 시도할 경우 글로벌 락이 해제될 때까지 대기 큐에서 대기한다.

사용 예시 : 여러 데이터베이스에 존재하는 MyISAM이나 MEMORY 테이블에 대해 mysqldump로 일관된 백업을 받야아 할 때 글로벌 락 사용

하지만, 해당 명령은 모든 테이블에 락을 걸기 위해 이전에 대기 중이던 모든 작업이 끝날 때까지 기다린 후에 실행된다.
-> 모든 테이블에 큰 영향을 미치므로, 가급적 사용하지 않는 것이 좋다.
* mysqldump같은 백업 프로그램은 내부적으로 해당 명령을 사용할 수 있으므로 체크 후에 사용해야 한다.

MySQL 8.0부터는 InnoDB가 기본 스토리지 엔진으로 채택되면서 조금 더 가벼운 글로벌 락의 필요성이 생김.
* Xtrabackup과 Enterprise Backup같은 백업 툴들의 안정적인 실행을 위해 백업 락이 도입됨.
  * 백업 락은 일반적인 테이블의 데이터 변경은 허용된다.

왜 그럴까? 
> 💡일반적인 MySQL의 서버 구성은 소스 서버(Source server)와 레플리카 서버(Replica server)로 구성되는데, 주로 백업은 replica 서버에서 실행된다.

* 만약 스키마 변경이 실행되면 백업이 실패한다.
  * 해당 DDL문 하나로 몇시간에 걸친 백업이 실패하면 다시 시간을 들여서 백업을 실행해야 한다.
  * 백업 락을 통해 백업의 실패를 막는다. DDL 명령이 실행되면 복제를 일시 중지하는 역할을 한다.

### 테이블 락
> 💡개별 테이블 단위로 설정되는 잠금이다.

명시적 또는 묵시적으로 할 수 있다.

[명시적]
> LOCK TABLES table_name [READ|WRITE]

* UNLOCK TABLES 명령으로 락을 반납(해제) 할 수 있다.
* 특별한 상황이 아니면 애플리케이션에서 사용할 필요가 거의 없음
  * 명시적으로 테이블을 잠그는 것 자체가 글로벌 락과 비슷한 맥락에서 상당한 영향을 미치기 때문이다.

[묵시적 테이블 락]
* MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 치면 발생
  * 변경되는 테이블에 락을 걸고 데이터를 변경 후에 락을 해제한다.
* InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 락을 제공함
  * 단순 데이터 변경 쿼리로 인해 테이블 락이 걸리지는 않음.
  * DDL의 경우에만 영향을 미친다.

### 네임드 락
> 💡GET_LOCK() 함수를 이용해 임의의 문자열에 대해 락을 설정할 수 있다.

락의 대상이 DB 객체가 아니고, 사용자가 지정한 문자열(String)에 대해 획득하고 반납(해제)하는 잠금이다.
* 자주 사용되지는 않음.
* 클라이언트가 상호 동기화를 처리해야 할 때 named lock을 사용하면 해결이 쉽다.
  * db 서버에 5대의 서버가 접속하려는 상황에서 5대의 웹 서버가 어떤 정보를 동기화해야 하는 요건
* 많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용됨.
  * 배치 프로그램처럼 한꺼번에 많은 레코드를 변경하는 쿼리는 데드락의 원인이 될 수 있다.

### 메타데이터 락(Metadata Lock)
* 데이터베이스 객체(table, view)의 이름이나 구조를 변경할 때 획득하는 lock이다.
* 메타데이터 락은 명시적으로 획득, 해제하는 것이 아니고 `RENAME TABLE tab_a TO tab_b` 와 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 락이다.

## InnoDB 스토리지 엔진 락
* MySQL 엔진의 락과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재한다.
  * 이를 통해 MyISAM보다 훨씬 뛰어난 동시성 처리를 제공할 수 있다.
  * 하지만, 이원하된 락 처리 탓에 InnoDB에서 사용되는 락의 정보는 MYSQL 명령을 이용해 접근하기가 상당히 어렵다.

* 최근 버전(8.0)에서는 InnoDB의 트랜잭션과 락, 잠금 대기 중인 트랜잭션의 목록을 조회할 수 있는 방법이 도입되었다.
  * `5.1` 버전부터는 `information_schema` 데이터베이스에 존재하는 `INNODB_TRX`, `INNODB_LOCKS`, `INNODB_LOCK_WAITS` 라는 테이블을 조인해서 조회하면 확인할 수 있다.
  * `8.0` 버전부터는 `performance_schema` 의 `data_locks`, `data_lock_waits` 테이블로 대체되고 있다.

* 레코드 락이 페이지 락, 테이블 락으로 업그레이드 되는 (락 에스컬레이션)은 없다.

인덱스를 걸지 않았다면 UPDATE쿼리에서 TABLE FULL SCAN을 하는 동안 모두 락이 걸린다.

### 레코드 락
* 레코드 자체만을 잠그는 것.
* InnoDB의 경우에는 레코드가 아니라, 인덱스의 레코드를 잠그는 것.
  * 인덱스가 별도로 없어도 클러스터 인덱스를 잠근다.
  * 보조 인덱스를 이용한 변경 작업 -> 넥스트 키 락, 갭 락을 이용함.

### 갭 락(Gap Lock)
* 갭 락은 레코드 자체가 아니라, 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다.
* 갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드의 INSERT를 막는다. 
* 단독적으로 쓰이기보다는 넥스트 키 락의 일부로 사용된다.

### 넥스트 키 락(Next Key Lock)
* 레코드 락 + 갭 락을 합쳐 놓은 형태의 락을 넥스트 키 락이라고 한다.
* REPEATABLE READ 격리 수준을 사용해야 한다.
* `innodb_locks_unsafe_for_binlog` 시스템 변수가 비활성화되면(0) 변경을 위해 검색하는 레코드에 넥스트 키 락 방식으로 잠금이 걸린다.
* InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적이다.

* 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나, 다른 트랜잭션이 기다리는 일이 빈번하다.
  * 바이너리 로그 포맷을 ROW 형태로 바꾸면 해결할 수 있다.

### 바이너리 로그 포맷
Statement, Row, Mixed 3가지 형태가 있다.

* Statement : 명령문 기반의 로깅 방식
  * 조건 -> REPEATABLE READ 이상의 격리 수준.
    * READ-COMMITTED 방식의 경우 하나의 트랜잭션에서 실행 시점에 따라 스냅샷이 달라지기 때문에 데이터가 불일치하는 문제가 발생할 수 있음.
* Row : 행 기반의 데이터 로깅 방식(8.0부터 DEFAULT)
* Mixed : Statement와 Row의 장점을 혼합한 로깅 방식
  * Statement 방식을 사용하며 실행된 쿼리와 스토리지 엔진의 종류에 따라 필요시 자동으로 Row포맷으로 전환 후 로그에 기록

### AUTO-INCREMENT LOCK
AUTO-INCREMENT 컬럼에 동시성 문제를 막기 위해 테이블 수준의 AUTO-INCREMENT 락을 지원.

* 당연히 INSERT문에서만 걸린다.
* 명시적으로 획득, 해제하는 방법은 없다.