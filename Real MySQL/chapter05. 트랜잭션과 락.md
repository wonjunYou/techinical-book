# 트랜잭션과 잠금

## MySQL에서의 트랜잭션
* 트랜잭션은 꼭 여러 개의 변경 작업을 수행하는 쿼리가 조합됐을 때만 의미 있는 개념은 아니다.
* 하나의 논리적인 작업 셋에 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 무관하다.
  * 단지 ALL Commit or All Rollback을 해야 한다.
* MySQL에서도 메모리 기반 스토리지 엔진인 MyISAM, InnoDB 스토리지 기반 엔진이 있다.
  * MyISAM, MEMORY는 트랜잭션을 지원하지 않는다.

ALL COMMIT, OR ALL ROLLBACK이라는 Transaction의 원자성을 보장하지 않으므로
MyISAM 테이블에서는 부분 업데이트 문제가 발생한다.(정합성의 보장이 어려워진다.)

* 트랜잭션의 범위를 최소화하라.
* DB 커넥션의 개수가 한정적.
  * 메일 전송이나 FTP 파일 전송 작업 등 네트워크를 통해 원격 서버와 통신하는 작업은 어떻게 해서든 DBMS의 트랜잭션 내에서 제거하는 것이 좋다.
* 비슷한 작업은 한 트랜잭션 내에서 처리하도록 하고, 성격이 다른 작업들은 별도의 트랜잭션으로 분리하라.

## MySQL 엔진의 레벨의 Lock

### Lock의 레벨(스토리지 엔진 레벨, MySQL 엔진 레벨)
크게 **스토리지 엔진 레벨과 MySQL 엔진 레벨로 나눌 수 있다.** 
MySQL 엔진이란 MySQL 서버에서 스토리지 엔진을 제외한 나머지 부분으로 이해하면 된다.

* MySQL 엔진 레벨 -> 모든 스토리지 엔진에 영향을 미침.
  * 테이블 데이터 동기화를 위한 테이블 락, 테이블의 구조를 잠그는 메타데이터 락, 사용자의 필요에 맞게 사용 가능한 네임드 락
* 스토리지 엔진 레벨 -> 스토리지 엔진 간에 상호 영향은 없음.'

### 글로벌 락(GLOBAL LOCK)
> 💡FLUSH TABLES WITH READ LOCK

MySQL에서 제공하는 락 가운데 가장 범위가 크다.(대상 : MySQL 서버 전체)
-> 작업 대상 테이블이나 DB가 다르더라도 동일하게 영향을 미친다.

한 세션에서 글로벌 락을 획득시, 다른 세션에서 쓰기 작업을 시도할 경우 글로벌 락이 해제될 때까지 대기 큐에서 대기한다.

사용 예시 : 여러 데이터베이스에 존재하는 MyISAM이나 MEMORY 테이블에 대해 mysqldump로 일관된 백업을 받야아 할 때 글로벌 락 사용

하지만, 해당 명령은 모든 테이블에 락을 걸기 위해 이전에 대기 중이던 모든 작업이 끝날 때까지 기다린 후에 실행된다.
-> 모든 테이블에 큰 영향을 미치므로, 가급적 사용하지 않는 것이 좋다.
* mysqldump같은 백업 프로그램은 내부적으로 해당 명령을 사용할 수 있으므로 체크 후에 사용해야 한다.

MySQL 8.0부터는 InnoDB가 기본 스토리지 엔진으로 채택되면서 조금 더 가벼운 글로벌 락의 필요성이 생김.
* Xtrabackup과 Enterprise Backup같은 백업 툴들의 안정적인 실행을 위해 백업 락이 도입됨.
  * 백업 락은 일반적인 테이블의 데이터 변경은 허용된다.

왜 그럴까? 
> 💡일반적인 MySQL의 서버 구성은 소스 서버(Source server)와 레플리카 서버(Replica server)로 구성되는데, 주로 백업은 replica 서버에서 실행된다.

* 만약 스키마 변경이 실행되면 백업이 실패한다.
  * 해당 DDL문 하나로 몇시간에 걸친 백업이 실패하면 다시 시간을 들여서 백업을 실행해야 한다.
  * 백업 락을 통해 백업의 실패를 막는다. DDL 명령이 실행되면 복제를 일시 중지하는 역할을 한다.

### 테이블 락
> 💡개별 테이블 단위로 설정되는 잠금이다.

명시적 또는 묵시적으로 할 수 있다.

[명시적]
> LOCK TABLES table_name [READ|WRITE]

* UNLOCK TABLES 명령으로 락을 반납(해제) 할 수 있다.
* 특별한 상황이 아니면 애플리케이션에서 사용할 필요가 거의 없음
  * 명시적으로 테이블을 잠그는 것 자체가 글로벌 락과 비슷한 맥락에서 상당한 영향을 미치기 때문이다.

[묵시적 테이블 락]
* MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 치면 발생
  * 변경되는 테이블에 락을 걸고 데이터를 변경 후에 락을 해제한다.
* InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 락을 제공함
  * 단순 데이터 변경 쿼리로 인해 테이블 락이 걸리지는 않음.
  * DDL의 경우에만 영향을 미친다.

### 네임드 락
> 💡GET_LOCK() 함수를 이용해 임의의 문자열에 대해 락을 설정할 수 있다.

락의 대상이 DB 객체가 아니고, 사용자가 지정한 문자열(String)에 대해 획득하고 반납(해제)하는 잠금이다.
* 자주 사용되지는 않음.
* 클라이언트가 상호 동기화를 처리해야 할 때 named lock을 사용하면 해결이 쉽다.
  * db 서버에 5대의 서버가 접속하려는 상황에서 5대의 웹 서버가 어떤 정보를 동기화해야 하는 요건
* 많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용됨.
  * 배치 프로그램처럼 한꺼번에 많은 레코드를 변경하는 쿼리는 데드락의 원인이 될 수 있다.

### 메타데이터 락(Metadata Lock)
* 데이터베이스 객체(table, view)의 이름이나 구조를 변경할 때 획득하는 lock이다.
* 메타데이터 락은 명시적으로 획득, 해제하는 것이 아니고 `RENAME TABLE tab_a TO tab_b` 와 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 락이다.

## InnoDB 스토리지 엔진 락
* MySQL 엔진의 락과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재한다.
  * 이를 통해 MyISAM보다 훨씬 뛰어난 동시성 처리를 제공할 수 있다.
  * 하지만, 이원하된 락 처리 탓에 InnoDB에서 사용되는 락의 정보는 MYSQL 명령을 이용해 접근하기가 상당히 어렵다.

* 최근 버전(8.0)에서는 InnoDB의 트랜잭션과 락, 잠금 대기 중인 트랜잭션의 목록을 조회할 수 있는 방법이 도입되었다.
  * `information_schema` 데이터베이스에 존재하는 `INNODB_TRX`, `INNODB_LOCKS`, `INNODB_LOCK_WAITS` 라는 테이블을 조인해서 조회하면 확인할 수 있다.
